export const meta = {
  title: `Manage MFA settings`,
  description: `Learn how to enable multi-factor authentication with Amplify.`,
};

[comment]: # (source content from /src/fragments/lib/auth/js/mfa.mdx ; /src/fragments/lib/auth/js/emailpassword.mdx ; /src/fragments/lib/auth/common/device_features/common.mdx ; /src/fragments/lib/auth/js/device_features/10_rememberDevice.mdx ; /src/fragments/lib/auth/js/device_features/20_forgetDevice.mdx ; /src/fragments/lib/auth/js/device_features/30_fetchDevice.mdx)

<InlineFilter filters={["js"]}>

MFA (Multi-factor authentication) increases security for your app by adding an authentication method and not relying solely on the username (or alias) and password. In this guide we will review how you can set up MFA using Time-based-One-Time Passwords (TOTP) and Short Message Service (SMS). This includes understanding when to use TOTP or SMS as a second layer with your MFA and the tradeoffs between these models to help you choose the right model for your application. Weâ€™ll also review how to set up MFA to forget devices and additional advanced use cases.

Before you begin you will need:
- An Amplify project with the Auth category configured
- The Amplify libraries installed and configured
- Access to your AWS account phone number if using SMS (for testing)

## Enable and Disable MFA

AWS Amplify uses Amazon Cognito to provide MFA. You will first enable MFA for your Cognito User Pool and then set up MFA for your app. Please see the [*Amazon Cognito Developer Guide*](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-settings-mfa.html) for more information to set up MFA in Amazon Cognito. You use the same Cognito console to enable or disable MFA.

When enabling MFA you will have two key decisions to make:
- **MFA enforcement:** As part of this setup you will determine how MFA is enforced. If you "Require MFA", all your users will need to complete MFA to sign in. If you you choose "Optional MFA", your users will have the choice on if they use MFA or not. 
- **MFA methods:** You will also specify which MFA method you are using - TOTP (Time-based One-time Password) or SMS (Short Message Service). We recommend that you use TOTP-based MFA as it is more secure and you can reserve SMS for account recovery.

<Accordion title='Compare TOTP and SMS MFA methods' headingLevel='3' eyebrow='Learn more'>

|  | Time-based One-time Password (TOTP) | Short Message Service (SMS) |
|:--|:--|:--|
| **Description** | Generates a short-lived numeric code for user authentication that includes a shared secret key and current time using an authenticator app. | Generates a one-time code shared via text message that is entered with other credentials for user authentication. |
| **Benefits** | More secure than SMS since the code is generated locally and not transmitted over a network. TOTP also works without cell service as long as the TOTP app is installed. | Easy to set up with a user-provided phone number and is familiar to users as a common authentication method. |
| **Constraints** | Requires an app to generate codes and adds to the initial setup of an account. Codes also expire quickly and must be used promptly after it is generated. | SMS requires cell service and can include an additional cost for the user. Although rare, SMS messages can also be intercepted. |

</Accordion>

<br/>

After you enable MFA you will also need to include MFA setup when users sign up. This will change depending on if you choose TOTP, SMS, or both.

### Set up TOTP

You can add Time-based One-time Password (TOTP) to your app which will ask users to complete authentication using a time-based one-time password (TOTP) after their username and password are verified. These TOTPs are generated using software token authentication apps like "Google Authenticator". When TOTP MFA is set up your user will be presented with a private key or QR code that they must enter into the TOTP-generating app. This app will then begin generating codes for the user to use for subsequent sign-in sessions.

You can set up TOTP for a user in your app with the `setupTOTPAuth` method. As part of this workflow you can also specify how users see the code retrieved from the authenticator app (e.g. numeric code or QR code), confirm the initial setup with the authenticator app, set TOTP as the preferred MFA method, and pass the TOTP code with the MFA type using the `confirmSignIn` method:

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { CognitoUserSession } from 'amazon-cognito-identity-js';
import { Auth } from 'aws-amplify';

type SetupTOTPAuthParameters = {
  user: string;
  challengeAnswer: string;
  mfaType?: 'SMS_MFA' | 'SOFTWARE_TOKEN_MFA';
};

export async function setupTOTPAuth({ user, challengeAnswer, mfaType }: SetupTOTPAuthParameters) {
  // To set up TOTP, first you need to get a `authorization code` from Amazon Cognito.
  // `user` is the current Authenticated user:
  const secretCode = await Auth.setupTOTP(user);

  // You can directly display the `code` to the user or convert it to a QR code to be scanned.
  // For example, use following code sample to render a QR code with `qrcode.react` component:
  //      import QRCodeCanvas from 'qrcode.react';
  //      const str = "otpauth://totp/AWSCognito:"+ username + "?secret=" + secretCode + "&issuer=" + issuer;
  //      <QRCodeCanvas value={str}/>

  // ...

  // Then you will have your TOTP account in your TOTP-generating app (like Google Authenticator)
  // use the generated one-time password to verify the setup.
  try {
    const cognitoUserSession: CognitoUserSession = await Auth.verifyTotpToken(
      user,
      challengeAnswer
    );
  // Don't forget to set TOTP as the preferred MFA method.
    await Auth.setPreferredMFA(user, 'TOTP');
  } catch (error) {
    // Token is not verified
  }

  // ...

  // Finally, when sign-in with MFA is enabled, use the `confirmSignIn` method
  // to pass the TOTP code and MFA type.
 const OTPCode = '123456'; // Code retrieved from authenticator app.
 await Auth.confirmSignIn(user, OTPCode, mfaType); // Optional, MFA Type e.g. SMS_MFA || SOFTWARE_TOKEN_MFA
}
```
</Block>
<Block name="JavaScript">

```js
import { Auth } from 'aws-amplify';

async function setupTOTPAuth(user, challengeAnswer, mfaType) {
  // To set up TOTP, first you need to get a `authorization code` from Amazon Cognito.
  // `user` is the current Authenticated user:
  const OTPCode = '123456'; // Code retrieved from authenticator app.

  // You can directly display the `code` to the user or convert it to a QR code to be scanned.
  // For example, use following code sample to render a QR code with `qrcode.react` component:
  //      import QRCodeCanvas from 'qrcode.react';
  //      const str = "otpauth://totp/AWSCognito:"+ username + "?secret=" + code + "&issuer=" + issuer;
  //      <QRCodeCanvas value={str}/>

  // ...

  // Then you will have your TOTP account in your TOTP-generating app (like Google Authenticator)
  // use the generated one-time password to verify the setup.
  try {
    const cognitoUserSession = await Auth.verifyTotpToken(user, challengeAnswer);
  // Don't forget to set TOTP as the preferred MFA method.
    await Auth.setPreferredMFA(user, 'TOTP');
  } catch (error) {
    // Token is not verified
  }

  // ...

  // Finally, when sign-in with MFA is enabled, use the `confirmSignIn` method
  // to pass the TOTP code and MFA type.
  await Auth.confirmSignIn(user, code, mfaType); // Optional, MFA Type e.g. SMS_MFA || SOFTWARE_TOKEN_MFA
}
```
</Block>
</BlockSwitcher>

<Accordion title='Additional considerations for TOTP MFA' headingLevel='4' eyebrow='Learn more'>

There are few limitations for TOTP MFA to keep in mind:
1. Amazon Cognito does not support hardware-based MFA. Use a software token MFA through an authenticator app that generates TOTP codes.
2. When TOTP is required your user must register with an authenticator app or subsequent sign-in attempts will fail.
3. Your users can use TOTP for MFA even if you disable TOTP for the user pool later.

To learn more details review the [*Amazon Cognito TOTP software token MFA*](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-settings-mfa-totp.html) documentation.

</Accordion>

### Set up SMS

You can also use Short Message Service (SMS) as a second layer of authentication with MFA. When SMS is enabled, your users will get an authentication code via a text message to complete sign-in after they sign in with their username and password. 

After you enable MFA with Amazon Cognito, you will also need to configure an IAM role to use with Amazon Simple Notification Service (Amazon SNS) to manage SMS messages. You will then add this role under the "Messaging" tab for your user pool in the Amazon Cognito console. For additional information see the [*Amazon Cognito SMS text message MFA*](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-settings-mfa-sms-text-message.html) documentation.

<Callout>

**Note:** If you create or update an SMS MFA configuration for your Cognito user pool, the Cognito service will send a test SMS message to an internal number in order to verify your configuration. You will be charged for these test messages by Amazon SNS. 

For information about Amazon SNS pricing, see [Worldwide SMS Pricing](https://aws.amazon.com/sns/sms-pricing/).

</Callout>

You will then want to update your app UI to prompt your users to enter their phone number to receive SMS codes. Then, when a user signs in, Amazon Cognito responds with a challenge that requires the user to provide an SMS verification code. This is where you can trigger `Auth.confirmSignIn()` and pass in the code provided by the user. Amplify will then verify with Cognito that the SMS code is valid and complete the sign-in process by returning access, ID, and refresh tokens that are all handled by Amplify internally. Once the user completes the SMS text message flow their phone number is marked as verified in your user pool.

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { Auth } from 'aws-amplify';

type ConfirmSignInWithMFAParameters = {
  username: string;
  password: string;
};

type MFAType = 'SMS_MFA' | 'SOFTWARE_TOKEN_MFA';

export async function signInWithMFA({ username, password }: ConfirmSignInWithMFAParameters) {
  try {
    const user = await Auth.signIn(username, password);
    if (user.challengeName === 'SMS_MFA' || user.challengeName === 'SOFTWARE_TOKEN_MFA') {
      // You need to get the code from the UI inputs
      // and then trigger the following function with a button click.
      const code: string = await getCodeFromUserInput();
      const mfaType: MFAType = await getMFATypeFromUserInput();
      // If MFA is enabled, sign-in should be confirmed with the confirmation code:
      const loggedUser = await Auth.confirmSignIn(
        user, // Return object from Auth.signIn()
        code, // Confirmation code
        mfaType // MFA Type e.g. SMS_MFA, SOFTWARE_TOKEN_MFA
      );
      console.log(loggedUser);
    } else {
      // The user directly signs in:
      console.log(user);
    }
  } catch (error) {
    console.log(`error signing in`, error);
  }
}

async function getCodeFromUserInput(): Promise<string> {
  // fetch code using a user form input
}
async function getMFATypeFromUserInput(): Promise<MFAType> {
  // fetch MFA type from user form input
}
```
</Block>
<Block name="JavaScript">

```javascript
import { Auth } from 'aws-amplify';

async function signInWithMFA() {
  try {
    const user = await Auth.signIn(username, password);
    if (
      user.challengeName === 'SMS_MFA' ||
      user.challengeName === 'SOFTWARE_TOKEN_MFA'
    ) {
      // You need to get the code from the UI inputs
      // and then trigger the following function with a button click.
      const code = getCodeFromUserInput();
      const mfaType = getMFATypeFromUserInput();
      // If MFA is enabled, sign-in should be confirmed with the confirmation code
      const loggedUser = await Auth.confirmSignIn(
        user, // Return object from Auth.signIn()
        code, // Confirmation code
        mfaType // MFA Type e.g. SMS_MFA, SOFTWARE_TOKEN_MFA
      );
      console.log(loggedUser)
    } else { 
      // The user directly signs in
    console.log(user)
    }
  } catch (error) {
    console.log(`error signing in`, error);
  }
};
```
</Block>
</BlockSwitcher>

### Set up MFA preferred type

Both TOTP MFA and SMS MFA methods are supported by Amazon Cognito. If you provide the option for your users to choose their second authentication factor or opt out, then you will want to also save that preference for future sessions with the `setupMFAType` method:

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { Auth } from 'aws-amplify';


export async function setupMFAType() {
  // You can select preferred mfa type, for example:
  // Select TOTP as preferred.
  try {
    const user = await Auth.currentAuthenticatedUser();
    const data = await Auth.setPreferredMFA(user, 'TOTP');
    console.log(data);
  } catch (error) {
    console.log('error setting up MFA type', error);
  }

  // Select SMS as preferred.
  await Auth.setPreferredMFA(user, 'SMS');

  // Select no-mfa.
  await Auth.setPreferredMFA(user, 'NOMFA');
}
```
</Block>
<Block name="JavaScript">

```js
import { Auth } from 'aws-amplify';

const user = await Auth.currentAuthenticatedUser();
async function setupMFAType(user) {
  // You can select preferred mfa type, for example:
  // Select TOTP as preferred.
  try {
    const data = await Auth.setPreferredMFA(user, 'TOTP');
    console.log(data);
  } catch (error) {
    console.log('error setting up MFA type', error);
  }

// Select SMS as preferred.
  await Auth.setPreferredMFA(user, 'SMS');

  // Select no-mfa.
  await Auth.setPreferredMFA(user, 'NOMFA');
}
```
</Block>
</BlockSwitcher>

#### Retrieve current preferred MFA method

Once the preferred MFA method is set for your user you will then want to use the `getPreferredMFAType` method to call this preference for future sign-in confirmations:

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { Auth } from 'aws-amplify';


export async function getPreferredMFAType() {
  try {
  // Will retrieve the current mfa type from cache
  // `bypassCache` is optional, by default is false.
  // If set to true, it will get the MFA type from server 
  // side instead of from local cache.
  const user = await Auth.currentAuthenticatedUser();
  const data = await Auth.getPreferredMFA(user, { bypassCache: false });
  console.log('Current preferred MFA type is: ' + data);
    } catch (err) { 
    console.log(err)
  }
}
```
</Block>
<Block name="JavaScript">

```js
import { Auth } from 'aws-amplify';

async function getPreferredMFAType() {
try {
  // Will retrieve the current mfa type from cache
  // bypassCache is optional, by default is false.
  // If set to true, it will get the MFA type from server
  // side instead of from local cache.
  const user = await Auth.currentAuthenticatedUser();
  const data = await Auth.getPreferredMFA(user, { bypassCache: false });
  console.log('Current preferred MFA type is: ' + data);
  } catch (err) {
    console.log(err)
 }
}

```
</Block>
</BlockSwitcher>

<Callout warning>

To avoid unexpected responses from Cognito, it is recommended to call `Auth.setPreferredMFA()` to ensure a user has set their MFA method *before* retrieving MFA settings with `Auth.getPreferredMFA()`.

</Callout>

<Accordion title='Sign-in with custom auth challenges' headingLevel='3' eyebrow='Learn more'>

When signing in with user name and password, your user will either sign in directly or be asked to pass challenges to be authenticated. The `user` object returned from `Auth.signIn` will contain `challengeName` and `challengeParam` if the user needs to pass those challenges. You can call corresponding functions based on these two parameters.

Challenge Name:

- `SMS_MFA`: The user needs to input the code received from SMS message. You can submit the code by `Auth.confirmSignIn`.
- `SOFTWARE_TOKEN_MFA`: The user needs to input the OTP(one time password). You can submit the code by `Auth.confirmSignIn`.
- `NEW_PASSWORD_REQUIRED`: This happens when the user account is created through the Cognito console. The user needs to input the new password and required attributes. You can submit those data by `Auth.completeNewPassword`.
- `MFA_SETUP`: This happens when the MFA method is TOTP (time-based one time password) which requires the user to go through additional steps to generate passwords with an Authenticator app. You can start the setup process using `setupTOTPAuth`.
- `SELECT_MFA_TYPE`: This happens when both SMS and TOTP methods are enabled but neither is set as preferred. You can set up your frontend application to let users choose what type they want to use in the current session and set it using the `user.sendMFASelectionAnswer` function.

The following code is only to demonstrate these options:

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { Auth } from 'aws-amplify';

type SignInParameters = {
  username: string;
  password: string;
  mfaType?: 'SMS_MFA' | 'SOFTWARE_TOKEN_MFA';
};

type UserInput = {
  username: string;
  email: string;
  phone_number: string;
};

export async function signIn({ username, password, mfaType }: SignInParameters) {
  try {
    const user = await Auth.signIn(username, password);
    if (user?.challengeName === 'SMS_MFA' || user?.challengeName === 'SOFTWARE_TOKEN_MFA') {
      // You need to get the code from the UI inputs
      // and then trigger the following function with a button click
      const code: string = await getCodeFromUserInput();
      // If MFA is enabled, sign-in should be confirmed with the confirmation code
      const loggedUser = await Auth.confirmSignIn(
        user, // Return object from Auth.signIn()
        code, // Confirmation code
        mfaType // MFA Type e.g. SMS_MFA, SOFTWARE_TOKEN_MFA
      );
    } else if (user?.challengeName === 'NEW_PASSWORD_REQUIRED') {
      const { requiredAttributes } = user.challengeParam; // the array of required attributes, e.g ['email', 'phone_number']
      // You need to get the new password and required attributes from the UI inputs
      // and then trigger the following function with a button click
      // For example, the email and phone_number are required attributes
      const { username, email, phone_number }: UserInput =
        await getInfoFromUserInput();
      const loggedUser = await Auth.completeNewPassword(
        user, // the Cognito User Object
        newPassword, // the new password
        // OPTIONAL, the required attributes
        {
          email,
          phone_number,
        }
      );
    } else if (user?.challengeName === 'MFA_SETUP') {
      // This happens when the MFA method is TOTP
      // The user needs to setup the TOTP before using it
      // More info please check the Enabling MFA part
      await Auth.setupTOTP(user);
    } else if (user?.challengeName === 'SELECT_MFA_TYPE') {
      // You need to get the MFA method (SMS or TOTP) from user
      // and trigger the following function
      // user object needs to be CognitoUser type
      user.sendMFASelectionAnswer(mfaType, {
        onFailure: (err: Error) => {
          console.error(err);
        },
        mfaRequired: (challengeName, parameters) => {
          // Auth.confirmSignIn with SMS code
        },
        totpRequired: (challengeName, parameters) => {
          // Auth.confirmSignIn with TOTP code
        },
      });
    } else {
      // The user directly signs in
      console.log(user);
    }
  } catch (err) {
    if (err?.code === 'UserNotConfirmedException') {
      // The error happens if the user didn't finish the confirmation step when signing up
      // In this case you need to resend the code and confirm the user
      // About how to resend the code and confirm the user, please check the signUp part
    } else if (err?.code === 'PasswordResetRequiredException') {
      // The error happens when the password is reset in the Cognito console
      // In this case you need to call forgotPassword to reset the password
      // Please check the Forgot Password part.
    } else if (err?.code === 'NotAuthorizedException') {
      // The error happens when the incorrect password is provided
    } else if (err?.code === 'UserNotFoundException') {
      // The error happens when the supplied username/email does not exist in the Cognito user pool
    } else {
      console.log(err);
    }
  }
}

async function getCodeFromUserInput(): Promise<string> {
  // fetch code using a user form input
}
async function getInfoFromUserInput(): Promise<UserInput> {
  // fetch user inputs like username, email and phoneNumber
}
```
</Block>
<Block name="JavaScript">

```js
import { Auth } from 'aws-amplify';

async function signIn() {
  try {
    const user = await Auth.signIn(username, password);
    if (user?.challengeName === 'SMS_MFA' || user?.challengeName === 'SOFTWARE_TOKEN_MFA') {
      // You need to get the code from the UI inputs
      // and then trigger the following function with a button click
      const code = await getCodeFromUserInput();
      // If MFA is enabled, sign-in should be confirmed with the confirmation code
      const loggedUser = await Auth.confirmSignIn(
        user, // Return object from Auth.signIn()
        code, // Confirmation code
        mfaType // MFA Type e.g. SMS_MFA, SOFTWARE_TOKEN_MFA
      );
    } else if (user?.challengeName === 'NEW_PASSWORD_REQUIRED') {
      const { requiredAttributes } = user.challengeParam; // the array of required attributes, e.g ['email', 'phone_number']
      // You need to get the new password and required attributes from the UI inputs
      // and then trigger the following function with a button click
      // For example, the email and phone_number are required attributes
      const { username, email, phone_number } = await getInfoFromUserInput();
      const loggedUser = await Auth.completeNewPassword(
        user, // the Cognito User Object
        newPassword, // the new password
        // OPTIONAL, the required attributes
        {
          email, // from user input
          phone_number, // from user input
        }
      );
    } else if (user?.challengeName === 'MFA_SETUP') {
      // This happens when the MFA method is TOTP
      // The user needs to setup the TOTP before using it
      // More info please check the Enabling MFA part
      await Auth.setupTOTP(user);
    } else if (user?.challengeName === 'SELECT_MFA_TYPE') {
      // You need to get the MFA method (SMS or TOTP) from user
      // and trigger the following function
      // user object needs to be CognitoUser type
      user.sendMFASelectionAnswer(mfaType, {
        onFailure: (err) => {
          console.error(err);
        },
        mfaRequired: (challengeName, parameters) => {
          // Auth.confirmSignIn with SMS code
        },
        totpRequired: (challengeName, parameters) => {
          // Auth.confirmSignIn with TOTP code
        },
      });
    } else {
      // The user directly signs in
      console.log(user);
    }
  } catch (err) {
    if (err?.code === 'UserNotConfirmedException') {
      // The error happens if the user didn't finish the confirmation step when signing up
      // In this case you need to resend the code and confirm the user
      // About how to resend the code and confirm the user, please check the signUp part
    } else if (err?.code === 'PasswordResetRequiredException') {
      // The error happens when the password is reset in the Cognito console
      // In this case you need to call forgotPassword to reset the password
      // Please check the Forgot Password part.
    } else if (err?.code === 'NotAuthorizedException') {
      // The error happens when the incorrect password is provided
    } else if (err?.code === 'UserNotFoundException') {
      // The error happens when the supplied username/email does not exist in the Cognito user pool
    } else {
      console.log(err);
    }
  }
}

async function getCodeFromUserInput() {
  // fetch code using a user form input
}
async function getInfoFromUserInput() {
  // fetch user inputs like username, email and phoneNumber
}
```
</Block>
</BlockSwitcher>

</Accordion>

<br/>

You can now enable multi-factor authentication and specify your second authentication method with TOTP or SMS. Your users can set their preferred method and you can retrieve this for them when they sign in. You can now look to add features like remembering a device to reduce friction in the sign-in workflow.

## Remember a device

Remembering a device is useful in conjunction with MFA because it allows the second factor requirement to be automatically met when your user signs in on that device, thereby reducing friction in their sign-in experience.

<Callout>

**Note:** The [device tracking and remembering](https://aws.amazon.com/blogs/mobile/tracking-and-remembering-devices-using-amazon-cognito-your-user-pools/) features are currently not available within the library when using the federated OAuth flow with Cognito User Pools or Hosted UI. 

</Callout>

### Configure the Amplify Auth Category

You can enable the remembered device functionality in the Cognito User Pool console. To begin, go to your project directory and issue the command:

```bash
amplify auth console
```

Select the following option to open the Cognito User Pool console:

```bash
? Which Console
    User Pool
```

When the console opens, scroll down to the "Device Tracking" section and select the "Edit" button. This will render the following page allowing you to configure your preference for remembering a user's device.

![Edit device tracking options list is shown, with the don't remember highlighted.](/images/auth/webconsole_remember1.png)

Choose either "Always remember" to remember a user's device by default or "User Opt-in" to give the user the ability to choose.

When MFA is enabled you will have the option to suppress the second factor during multi-factor authentication. Choose "Yes" if you want a remembered device to be used as a second factor mechanism.

![Options for allow users to bypass MFA for trusted devices.](/images/auth/webconsole_remember2.png)

When you have made your selection(s), click "Save changes".  You are now ready to start updating your code to manage remembered devices.

<Accordion title='Understand key terms used for tracking devices' headingLevel='4' eyebrow='Learn more'>

There are differences to keep in mind when working with remembered, forgotten, and tracked devices.

* **Tracked:** Every time the user signs in with a new device, the client is given the device key at the end of a successful authentication event. We use this device key to generate a salt and password verifier which is used to call the `ConfirmDevice` API. At this point, the device is considered to be "tracked".  Once the device is in a tracked state, you can use the Amazon Cognito console to see the time it started to be tracked, last authentication time, and other information about that device.
* **Remembered:** Remembered devices are also tracked. During user authentication, the device key and secret pair assigned to a remembered device is used to authenticate the device to verify that it is the same device that the user previously used to sign in.
* **Not Remembered:** A not-remembered device is a tracked device where Cognito has been configured to require users to "Opt-in" to remember a device but the user has chosen not to remember the device. This use case is for users signing into their application from a device that they don't own.
* **Forgotten:** In the event that you no longer want to remember or track devices, you can use the `Auth.forgetDevice()` API to remove devices from being both remembered and tracked.

</Accordion>

### Remember devices

You can remember devices using the following:

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { Auth } from 'aws-amplify';

export async function rememberDevice() {
  try {
    const result = await Auth.rememberDevice();
    console.log(result);
  } catch (error) {
    console.log('Error remembering device', error);
  }
}
```
</Block>
<Block name="JavaScript">

```js
import { Auth } from 'aws-amplify';

async function rememberDevice() {
  try {
    const result = await Auth.rememberDevice();
    console.log(result);
  } catch (error) {
    console.log('Error remembering device', error);
  }
}
```
</Block>
</BlockSwitcher>

### Forget devices

You can also forget devices but note that forgotten devices are still tracked.

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { Auth } from 'aws-amplify';

export async function forgetDevice() {
  try {
    await Auth.forgetDevice();
  } catch (error) {
    console.log('Error forgetting device', error);
  }
}
```
</Block>
<Block name="JavaScript">

```js
import { Auth } from 'aws-amplify';

async function forgetDevice() {
  try {
    await Auth.forgetDevice();
  } catch (error) {
    console.log('Error forgetting device', error);
  }
}
```
</Block>
</BlockSwitcher>

### Fetch devices

You can fetch a list of remembered devices by using the following:

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { Auth } from 'aws-amplify';

export async function fetchDevices() {
  try {
    const result = await Auth.fetchDevices();
    console.log(result);
  } catch (err) {
    console.log('Error fetching devices', err);
  }
}
```
</Block>
<Block name="JavaScript">

```js
import { Auth } from 'aws-amplify';

async function fetchDevices() {
  try {
    const result = await Auth.fetchDevices();
    console.log(result);
  } catch (err) {
    console.log('Error fetching devices', err);
  }
}
```
</Block>
</BlockSwitcher>

You can now set up devices to be remembered, forgotten, and fetched.

## Conclusion

Congratulations! You finished the **Manage MFA settings** guide. In this guide, you set up and configured MFA for your users and provided them options on remembering their MFA preferences and devices.

## Next steps

Now that you completed setting up multi-factor authentication you may also want to add additional customization. We recommend you learn more about:
* [Switching authentication flows](/lib/auth/switch-auth/q/platform/js/)
* [Advanced workflows](/lib/auth/advanced/q/platform/js/)

</InlineFilter>

import reactnative0 from "/src/fragments/lib/auth/js/mfa.mdx";

<Fragments fragments={{'react-native': reactnative0}} />

import flows from "/src/fragments/lib/auth/common/mfa/flows.mdx";

<Fragments fragments={{ios: flows, flutter: flows, android: flows}} />
